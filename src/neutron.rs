use crate::{camera::Camera, math::*};
use alloc::collections::vec_deque::VecDeque;
use rast::tint::*;

const AU: f64 = 1.496e11;
const SCALE: f64 = 20.0;
const TRAIL_LEN: usize = 1_000;
const NEPTUNE_DIST: f64 = 4.4706e12;

pub struct NeutronMemory {
    bodies: [CelestialBody; 9],
}

impl Default for NeutronMemory {
    fn default() -> Self {
        Self {
            // Initial values generated by NASA Horizons System tool.
            // Body ids are found here:
            // https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/req/naif_ids.html
            bodies: [
                // Sun
                CelestialBody::new(fetch_spatial_data(10), Srgb::rgb(255, 255, 255)),
                // Mercury
                CelestialBody::new(fetch_spatial_data(199), Srgb::rgb(255, 255, 255)),
                // Venus
                CelestialBody::new(fetch_spatial_data(299), Srgb::rgb(255, 255, 255)),
                // Earth
                CelestialBody::new(fetch_spatial_data(399), Srgb::rgb(0, 0, 255)),
                // Mars
                CelestialBody::new(fetch_spatial_data(499), Srgb::rgb(255, 255, 255)),
                // Jupiter
                CelestialBody::new(fetch_spatial_data(599), Srgb::rgb(255, 255, 255)),
                // Saturn
                CelestialBody::new(fetch_spatial_data(699), Srgb::rgb(255, 255, 255)),
                // Uranus
                CelestialBody::new(fetch_spatial_data(799), Srgb::rgb(255, 255, 255)),
                // Neptune
                CelestialBody::new(fetch_spatial_data(899), Srgb::rgb(255, 255, 255)),
            ],
        }
    }
}

#[derive(Debug)]
struct CelestialBody {
    spatial: SpatialData,
    color: Srgb,
    trail: VecDeque<Vec3>,
}

impl CelestialBody {
    fn new(mut spatial: SpatialData, color: Srgb) -> Self {
        core::mem::swap(&mut spatial.translation.y, &mut spatial.translation.z);
        core::mem::swap(&mut spatial.velocity.y, &mut spatial.velocity.z);

        Self {
            trail: VecDeque::with_capacity(
                ((spatial.translation / NEPTUNE_DIST).length() * TRAIL_LEN as f64) as usize,
            ),
            color,
            spatial,
        }
    }
}

#[derive(Debug)]
struct SpatialData {
    // meters
    radius: f64,
    // kg
    mass: f64,
    // meters
    translation: DVec3,
    // mps
    velocity: DVec3,
    // mps2
    acceleration: DVec3,
}

pub fn update(memory: &mut NeutronMemory, dt: f32) {
    let dt = dt as f64;
    for _ in 0..10000 {
        step(memory, dt);
    }
    for body in memory.bodies.iter_mut() {
        if body.trail.len() >= body.trail.capacity() {
            body.trail.pop_front();
        }
        body.trail
            .push_back((body.spatial.translation / AU * SCALE).to_vec3());
    }
}

fn step(memory: &mut NeutronMemory, dt: f64) {
    for body in memory.bodies.iter_mut() {
        body.spatial.acceleration = DVec3::ZERO;
    }

    for i in 0..memory.bodies.len() {
        for j in 0..memory.bodies.len() {
            if i != j {
                let b1 = &memory.bodies[i];
                let b2 = &memory.bodies[j];

                let m1 = b1.spatial.mass;
                let m2 = b2.spatial.mass;
                let r3 = libm::pow(b1.spatial.translation.distance(b2.spatial.translation), 3.0);
                // https://en.wikipedia.org/wiki/Gravitational_constant
                let g = 6.674e-11;

                let r12 = b1.spatial.translation - b2.spatial.translation;
                let m1m2 = m1 * m2;
                let fv = r12 * -g * m1m2 / r3;
                memory.bodies[i].spatial.acceleration += fv / b1.spatial.mass;
            }
        }
    }

    let time_factor = 1000.0;
    for body in memory.bodies.iter_mut() {
        body.spatial.velocity += body.spatial.acceleration * dt * time_factor;
        body.spatial.translation += body.spatial.velocity * dt * time_factor;
    }
}

pub fn render(
    memory: &mut NeutronMemory,
    frame_buffer: &mut [Srgb],
    zbuffer: &mut [f32],
    width: usize,
    height: usize,
    camera: &Camera,
) {
    frame_buffer.fill(Srgb::rgb(0, 0, 0));
    zbuffer.fill(1.0);
    draw_vanishing_lines(frame_buffer, width, height, camera);
    draw_system(memory, frame_buffer, zbuffer, width, height, camera);
}

fn draw_system(
    memory: &NeutronMemory,
    frame_buffer: &mut [Srgb],
    zbuffer: &mut [f32],
    width: usize,
    height: usize,
    camera: &Camera,
) {
    for body in memory.bodies.iter() {
        if body.trail.len() < 2 {
            continue;
        }

        for i in 0..body.trail.len() - 1 {
            let p1 = body.trail[i];
            let p2 = body.trail[i + 1];

            let v1 = crate::math::vertex_world_to_screen_space_clipped(width, height, camera, p1);
            let v2 = crate::math::vertex_world_to_screen_space_clipped(width, height, camera, p2);
            if let (Some(v1), Some(v2)) = (v1, v2) {
                rast::rast_line_checked(
                    frame_buffer,
                    zbuffer,
                    width,
                    height,
                    v1.x as i32,
                    v1.y as i32,
                    v1.z,
                    v2.x as i32,
                    v2.y as i32,
                    v2.z,
                    body.color,
                );
            }
        }
    }

    for body in memory.bodies.iter() {
        let t = (body.spatial.translation / AU * SCALE).to_vec3();
        if let Some(proj) =
            crate::math::vertex_world_to_screen_space_clipped(width, height, camera, t)
        {
            let scale = 20.0;
            let corners = [
                Vec2::new(0.0, 0.0),
                Vec2::new(1.0, 0.0),
                Vec2::new(1.0, 1.0),
                Vec2::new(0.0, 1.0),
            ]
            .map(|v| (v - 0.5) * scale + proj.to_vec2());

            rast::rast_quad_colored(
                frame_buffer,
                width,
                height,
                corners[0].x as i32,
                corners[0].y as i32,
                corners[1].x as i32,
                corners[1].y as i32,
                corners[2].x as i32,
                corners[2].y as i32,
                corners[3].x as i32,
                corners[3].y as i32,
                body.color,
            );
        }
    }
}

// TODO: Need a way to clip the points such that when one is offscreen
// the projection is correct.
#[allow(unused)]
fn draw_vanishing_lines(frame_buffer: &mut [Srgb], width: usize, height: usize, camera: &Camera) {
    for [p1, p2] in [
        [Vec3::x(-100.0), Vec3::x(100.0)],
        [Vec3::z(-100.0), Vec3::z(100.0)],
    ] {
        // let v1 = crate::math::vertex_world_to_screen_space(width, height, camera, p1);
        // let v2 = crate::math::vertex_world_to_screen_space(width, height, camera, p2);
        // rast::rast_line(
        //     frame_buffer,
        //     width,
        //     height,
        //     v1.x as i32,
        //     v1.y as i32,
        //     v1.z,
        //     v2.x as i32,
        //     v2.y as i32,
        //     v2.z,
        //     Srgb::rgb(62, 62, 62),
        // );
    }
}

fn fetch_spatial_data(body: i32) -> SpatialData {
    extern crate std;
    use std::process::Command;
    use std::string::String;

    let output = Command::new("curl")
        .arg("-s")
        .arg("https://ssd.jpl.nasa.gov/api/horizons.api")
        .arg("-G")
        .arg("-d")
        .arg("format=text")
        .arg("-d")
        .arg(&alloc::format!("COMMAND={body}"))
        .arg("-d")
        .arg("OBJ_DATA=YES")
        .arg("-d")
        .arg("MAKE_EPHEM=YES")
        .arg("-d")
        .arg("EPHEM_TYPE=VECTORS")
        .arg("-d")
        .arg("CENTER=@0")
        .arg("-d")
        .arg("START_TIME=2024-01-01")
        .arg("-d")
        .arg("STOP_TIME=2024-01-02")
        .arg("-d")
        .arg("STEP_SIZE=1d")
        .arg("-d")
        .arg("VEC_TABLE=2")
        .arg("-d")
        .arg("REF_PLANE=ECLIPTIC")
        .arg("-d")
        .arg("REF_SYSTEM=J2000")
        .arg("-d")
        .arg("OUT_UNITS=KM-S")
        .output()
        .expect("failed to execute curl process");
    assert!(
        output.status.success(),
        "failed to curl query horizons api: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    let data = String::from_utf8_lossy(&output.stdout);
    parse_horizons_data(&data)
}

fn parse_horizons_data(data: &str) -> SpatialData {
    // Data example
    //
    // $$SOE
    // 2460310.500000000 = A.D. 2024-Jan-01 00:00:00.0000 TDB
    //  X =-2.600298246493929E+07 Y = 1.445600958366426E+08 Z = 2.324604087693989E+04
    //  VX=-2.983302263902714E+01 VY=-5.138481408411204E+00 VZ= 1.105037462794778E-03
    // 2460311.500000000 = A.D. 2024-Jan-02 00:00:00.0000 TDB
    //  X =-2.857666444771557E+07 Y = 1.440936304180347E+08 Z = 2.334921608994901E+04
    //  VX=-2.974143119003039E+01 VY=-5.659136117359448E+00 VZ= 1.277159610630907E-03
    // $$EOE

    // km units, need to be mapped to m
    assert!(data.contains("Output units    : KM-S"));

    let mut x = 0.0;
    let mut y = 0.0;
    let mut z = 0.0;
    let mut vx = 0.0;
    let mut vy = 0.0;
    let mut vz = 0.0;

    for line in data
        .split_once("$$SOE")
        .expect("bad horizons data")
        .1
        .lines()
        .skip(2)
        .take(2)
    {
        if line.contains("X =") && line.contains("Y =") && line.contains("Z =") {
            x = extract_f64(line, "X") * 1e3;
            y = extract_f64(line, "Y") * 1e3;
            z = extract_f64(line, "Z") * 1e3;
        }
        if line.contains("VX=") && line.contains("VY=") && line.contains("VZ=") {
            vx = extract_f64(line, "VX") * 1e3;
            vy = extract_f64(line, "VY") * 1e3;
            vz = extract_f64(line, "VZ") * 1e3;
        }
    }

    assert!(x != 0.0);
    assert!(y != 0.0);
    assert!(z != 0.0);
    assert!(vx != 0.0);
    assert!(vy != 0.0);
    assert!(vz != 0.0);

    let mass_prefix = "Mass,xkg(kg)=~";
    let mass_idx = data.find("Mass").unwrap();
    let mass_after_conv = data[mass_idx..].find("10^").unwrap();
    let power = data[mass_idx + mass_after_conv + 3..mass_idx + mass_after_conv + 5]
        .parse::<f64>()
        .unwrap();

    let mass_str = data[mass_idx + mass_after_conv + 5..]
        .trim_start_matches(|c: char| c.is_whitespace() || mass_prefix.contains(c));
    let end = mass_str
        .find(|c: char| c.is_whitespace() || ['+', '-'].contains(&c))
        .unwrap();
    let mass = mass_str[..end].parse::<f64>().unwrap() * libm::pow(10.0, power);

    // TODO: Fuck this dataset
    let radius_prefix = "Equat.EquatorialradiusSolar(IAU2015)(km)Re,(1bar)= ";
    let radius_idx = data.find("Equatorial radius").unwrap_or_else(|| {
        data.find("Equat. radius").unwrap_or_else(|| {
            data.find("Equ. radius").unwrap_or_else(|| {
                data.find("Equatorial Radius")
                    .unwrap_or_else(|| data.find("Solar radius").unwrap())
            })
        })
    });
    let radius_str = data[radius_idx..].trim_start_matches(|c: char| radius_prefix.contains(c));
    let end = radius_str
        .find(|c: char| c.is_whitespace() || ['+', '-', '~'].contains(&c))
        .unwrap();
    let radius = radius_str[..end].parse::<f64>().unwrap() * 1e3;

    SpatialData {
        radius,
        mass,
        translation: DVec3::new(x, y, z),
        velocity: DVec3::new(vx, vy, vz),
        acceleration: DVec3::ZERO,
    }
}

fn extract_f64(line: &str, label: &str) -> f64 {
    let str = line
        .split_once(label)
        .unwrap_or_else(|| panic!("expected `{label}`"))
        .1
        .trim_start_matches(|c: char| c.is_whitespace() || label.contains(c) || c == '=');
    let end = str[1..]
        .char_indices()
        .find_map(|(i, c)| c.is_whitespace().then_some(i))
        .unwrap_or_else(|| str.len() - 1);
    str[..=end]
        .parse()
        .unwrap_or_else(|_| panic!("expected `{label}`"))
}
